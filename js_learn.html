<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="utf-8">
    <title>javascript learn</title>
    <script src="../learn_web/js_learn.js"></script>
</head>

<body>

    <h2>script tag 의 기초 옵션</h2>
    <br>
    <p>head tag 안에 script tag를 두면 그 tag 부분에서 html 파일의 parsing을 멈추고,</p>
    <p>js 파일이 너무 큰 경우 로딩이 너무 오래 걸림..</p>
    <br>
    <p>그래서 body tag 끝에 script tag를 두는 경우가 많음. </p>
    <p>컨텐츠 로딩이 이미 다 되어 있으니 컨텐츠는 빨리 봄. </p>
    <p>그런데 그 html 파일이 js에 의존이 큰 경우 기능 동작에 문제가 있음..</p>
    <br>
    <p>head tag 안에 script tag를 둘 때 boolean type의 asyn 옵션 두면 html parsing과 병렬로 다운로드함.</p>
    <p>body 끝 쪽에 두는 것에 비해 다운로드 받는 속도가 빠르기 때문에 준비는 빨라짐. </p>
    <p>단, 병렬로 다운로드가 끝나면 js를 excuting 하기 때문에 정작 필요한 시점에서 작동 안할 수도 있음. </p>
    <p>또 excuting js 동안 html parsing이 멈추기 때문에 용량이 클 경우 나머지 컨텐츠 로드가 늦어질 수 있음.</p>
    <br>
    <p>head tag 안에 script tag를 둘 때 defer 옵션을 두면 html parsing하면서 js를 다운로드 함.</p>
    <p>html parsing이 끝나면 excuting js, 따라서 html parsing이 끝나고 사용자에게 parsing이 끝난 화면을 보여주고 js를 실행하게 됨.</p>
    <br>
    <p>가장 안전하면서 의도한 대로 움직일 수 있는 옵션 defer !</p>
    <p>js를 만들 때 첫줄에 'use strict'; 를 작성 >> strict mode 로 개발하겠다!</p>


    <p>--------------------------------------------------------------------------------------------------------------</p>
    <br>
    <br>


    <h2>Variables 변수</h2>
    <br>

    <h3>Variable types</h3>
    <p>primitive, single item. 더이상 나눠지지 않음. >> 값 자체가 메모리에 저장됨.</p>
    <p>object, box container. single item 을 묶어서 단위로 사용.</p>
    <p>>> 크기가 커서 메모리에 바로 못올라감. 따라서 reference를 통해 실제로 저장되어 있는 메모리를 가리키게 됨.</p>
    <p>function, first-class function. >> 이게 지원된다? 그러면 변수처럼 사용 가능.</p>
    <br>
    <p>Immutable data type >> 데이터를 절대 변경하지 못함. primitive types, frozen objects</p>
    <p>Mutable data type >> 데이터를 변경할 수 있음. all objects by default are mutable in JS</p>


    <h3>ES6 부터 let ! >> Mutable Type >> rw</h3>
    <p>var는 이제 사용 X, 변수를 선언하기 전에 사용할 수 있기 때문에 오류를 유발할 수 있음.</p>
    <p>이걸 var hoisting 이라 하는데, 어디에 선언했냐에 상관 없이 선언을 최상단으로 끌어 올리는 것.</p>
    <p>즉, file 맨 위에 선언이 올라가버림. >> console 보면 undefined 로 나옴.</p>
    <p>또, block scope에 적용되지 않기 때문에 문제가 생길 수 있음.</p>
    <br>

    <h3>Constant const >> Immutable Type >> r</h3>
    <p>한번 선언하면 변경이 불가능한 변수. 따라서 항상 그 값이어야 하는 변수를 선언할 때 사용</p>
    <p>for security, thread safety, reduce human mistakes</p>
    <br>

    <p>숫자 number, JS에서는 dinamic하게 변수가 할당되기 때문에 number를 따로 선언 안해줘도 됨.</p>
    <p>단, infinity(양수를 0으로 나눔), negativeInfinity(음수를 0으로 나눔), not a number(숫자가 아닌 경우)는 표현 불가.</p>
    <p>큰 정수를 쓸 경우 bigInt type >> 숫자 뒤에 n 붙이면 됨. </p>
    <br>

    <h3>문자, 문장 string</h3>
    <p>template literals(string)을 많이 쓰는데, '${변수}, type: ${typeof 변수}' 쉽게 문장을 작성할 수 있음.</p>
    <br>

    <p>공백, null</p>
    <br>

    <h3>고유식별자, symbol</h3>
    <p>symbol로 선언한 string이 같아도 서로 다른 변수. >> 고유한 값을 가지는 식별자 </p>
    <p>만약 string이 같은 symbol을 선언할 때는 symbol.for('string'); >> 이때는 각 심볼이 서로 같음.</p>
    <br>

    <h3>JS는 Dynamic typing languages >> 변수 선언 시 따로 지정해주지 않아도 runtime에서 선언.</h3>
    <p>값에 따라 자동으로 변환도 되고 계산도 가능함.</p>
    <p>변수형을 따로 지정하지 않으면 runtime 중에 변수형이 변경되기 때문에 runtime 중에 오류가 발생할 수 있음.</p>
    <br>

    <p>구조체, object</p>
    <p></p>


    <p>--------------------------------------------------------------------------------------------------------------</p>
    <br>
    <br>

    <h2>Operator</h2>
    <br>

    <h3>String concatenation</h3>
    <p>+를 써서 문장을 합칠 수 있음. `string literals ${연산 할 내용}` 가능 (''와 혼동 조심)</p>
    <p>'string' + 숫자 일 경우, 숫자를 string으로 변환 후 문장을 합침.</p>
    <p>''로 string을 만드는 경우, 특수문자열을 이용해 문장부호나 조판부호 사용 가능.</p>
    <br>

    <h3>Numeric operator</h3>
    <p>숫자 연산에 사용. 연산부호 사용.</p>
    <br>

    <h3>Increment and decrement operator</h3>
    <p>preIncrement >> ++변수 , 변수 += 1; 과 같음. 연산 후에 대입.</p>
    <p>postIncrement >> 변수++ , 변수를 먼저 대입, 그 후에 +1</p>
    <p>preDecrement >> --변수 , 변수 -= 1; 과 같음. 연산 후에 대입.</p>
    <p>postDecrement >> 변수-- , 변수를 먼저 대입, 그 후에 -1</p>
    <br>

    <h3>Assignment operator, Comparison operator</h3>
    <p>Assignment operator >> +=, -=, *=, /= </p>
    <p>Comparison operator >> &lt; , &gt;, &lt;=, &gt;= </p>
    <br>

    <h3>Logical operator</h3>
    <p>|| >> or, 비교 대상 중 하나만 True면 True</p>
    <p>&& >> and, 비교 대상 모두가 True여야 True.</p>
    <p>>> 간단하게 null check에 쓰이기도 함. ~ nullobject가 null이 아닐 때만 값을 받아오기 떄문.</p>
    <p>|| 와 && 는 보다 심플한 대상을 앞으로. 보다 무거운 function은 뒤로!</p>
    <p>! >> 값을 반대로 바꿔줌.</p>
    <br>

    <h3>Equallity</h3>
    <p>loose equally == >> 서로 같은가? 비교 / != 는 서로 다른가? >> type을 변경해서 값을 비교</p>
    <p>strict equally === >> type을 비교해서 같은가? / !== 다른가?</p>
    <p>코딩할 땐 왠만하면 strict equally를 이용하기</p>
    <br>

    <h3>0, null, ''(empty string), undefined 는 false 로 간주!</h3>
    <br>

    <h3>Conditional operator</h3>
    <p>if elseif if 구문 >> 다른 언어랑 같음 >> if{}elseif{}else{};</p>
    <br>

    <h3>Ternary operator</h3>
    <p>조건 ? A : B >> 조건이 true면 A, 아니면 B 실행</p>
    <p>간단하게 쓸 때만 사용</p>
    <br>

    <h3>Switch statement</h3>
    <p>다른 언어의 stitch(조건){case} 와 같음</p>
    <p>if~else가 반복 될 때, typescript에서 정해져있는 type 검사할 때 등등에서 사용 </p>
    <br>

    <h3>Loop</h3>
    <p>다른 언어의 loop와 비슷함</p>
    <p>while(조건){} 은 조건 비교 후 실행, do{}while(조건) 은 일단 실행 후 조건 비교</p>
    <p>for(조건){} 은 다른 언어와 같은 방식. inline varialbe declaration 가능. 단, 중첩된 for 문은 권장 X</p>
    <br>
    <p>continue >> loop는 진행, 이번 구문만 skip</p>
    <p>break >> loop를 끝냄</p>
    <br>


    <p>--------------------------------------------------------------------------------------------------------------</p>
    <br>
    <br>

    <h2>Arrow Function</h2>
    <br>

    <h3>JavaScript >> 절차지향형 언어</h3>
    <br>

    <h3>Function</h3>
    <p>sub-program 이라고 부르기도. 프로그램 안에서 각각의 기능을 수행.</p>
    <p>Input / Output 이 있음. 재사용 가능.</p>
    <br>

    <h3>Function declaration</h3>
    <p>한 함수에 하나의 기능을 하게 설계.</p>
    <p>가능하면 동사 형태로 작명하여 이름으로 알아볼 수 있게 하기.</p>
    <p>Function은 Object로 쓸 수 있음</p>
    <br>

    <h3>Parameter</h3>
    <p>Function에 전달되는 값.</p>
    <p>premitive parameter >> value 전달</p>
    <p>object parameter >> reference 전달</p>
    <br>

    <h3>Default Parameter</h3>
    <p>ES6에서 추가 됨.</p>
    <p>Parameter = '원하는 Default 값' 으로 선언하여 사용자가 파라미터를 전달하지 않았을 때 출력할 default 값 지정.</p>
    <br>

    <h3>Rest parameter</h3>
    <p>배열 형태의 parameter >> ...parameter 로 전달</p>
    <p>다수의 인자를 전달할 때 배열의 형태로 전달하게 됨.</p>
    <br>

    <h3>Local scope</h3>
    <p>안에서는 밖을 볼 수 있지만, 밖에서는 안을 볼 수 없다!</p>
    <p>global variable >> block 밖에 선언되어 어디서나 사용 가능.</p>
    <p>local variable >> block 안에서 선언되어 그 안에서만 사용 가능.</p>
    <p>자식 요소는 부모 요소를 참조할 수 있으나, 부모 요소는 자식 요소를 참조할 수 없다.</p>
    <br>

    <h3>Return</h3>
    <p>함수의 결과 값을 return으로 전달 >> 모든 함수에서 사용. 정의가 없다? ~ return undefined; 가 생략된 것. </p>
    <br>

    <h3>Early return, Early exit</h3>
    <p>조건문을 사용할 때, 조건이 맞지 않는 경우, 값이 -1 이거나 undefined인 경우 return을 통해 loop를 탈출.</p>
    <p>코드를 보다 간결하고 실행과정이 짧아지도록 하는 것.</p>
    <br>


    <p>--------------------------------------------------------------------------------------------------------------</p>
    <br>
    <br>

    <h2>Function expression</h2>
    <br>

    <h3>First-class function</h3>
    <p>function은 다른 변수와 같이 사용 가능, 변수 할당 가능, 파라미터로 전달 가능, 다른 function에서 return 가능.</p>
    <p>함수를 선언함과 동시에 변수에 할당 >> 함수에 이름이 없음 ~ anonymous function</p>
    <p>const 변수 = function (함수 이름 / 생략 가능) {}; >> function의 이름이 있으면 named function</p>
    <p>named function으로 선언하는 이유 >> debuging 할 때 stack에서 함수를 확인하기 위함. 또는 함수 내에서 자신을 호출할 때.</p>
    <p>function declaration은 hoisting 가능 >> 정의 전에 호출이 된다. >> JS가 호출 부분을 최상단으로 옮겨주기 때문.</p>
    <p>function expression은 hoisting 불가능 >> 정의 전에 호출이 안된다.</p>
    <br>

    <h3>Callback</h3>
    <p>function의 parameter로 function을 전달할 때</p>
    <p>변수에 callback 할 funciton을 할당해두고 parameter로 전달.</p>
    <br>

    <h3>Arrow function</h3>
    <p>항상 anonymous function</p>
    <p>const fucntion-name = (parameter) => return; >> {}을 사용할 경우 return 필수 </p>
    <br>

    <h3>IIFE</h3>
    <p>함수를 선언하면서 바로 호출할 때 사용.</p>
    <p>(fucntion name(){})(); 형태로 사용.</p>
    <br>


    <p>--------------------------------------------------------------------------------------------------------------</p>
    <br>
    <br>

    <h2>Class & Object</h2>
    <br>

    <h3>class</h3>
    <p>ES6에 추가됨. 문법만 class가 추가된 것 뿐, 기존 기능을 활용</p>
    <p>Template >> no data. only template >> 정의만 하는 것. 실제로 메모리에 올라가지 않음.</p>
    <p>class에 data를 넣어 object를 만드는 것. >> instance</p>
    <br>

    <h3>Class declaration</h3>
    <p>class 안에는 field, method가 있음.</p>
    <p>class class-name{constructor(parameter){fields} method-name(){}}</p>
    <p>새로운 object 선언 >> new</p>
    <br>

    <h3>Getter & Setter</h3>
    <p>class를 생성하고 사용할 때 잘못된 값을 입력하더라도 방어적으로 처리하게 해주는 것.</p>
    <p>get parameter(){} 으로 return, set parameter(value){} 로 깂 살장 가능 >> 잘못된 입력 바로잡기 가능</p>
    <p>set parameter(value){} 은 값을 설정하는 것이므로 value가 필수</p>
    <p>if) class의 변수 = get의 parameter = set의 parameter 인 경우</p>
    <p> >> set의 this.parameter = value; 와 get의 return this.parameter; 로 인해 무한 호출, call stack error 발생</p>
    <p>따라서 get과 set에서 parameter의 이름을 변경 ~ _ 를 붙이는게 일반적. >> 해당 class 에서만 호출</p>
    <br>

    <h3>Static properties and methods</h3>
    <p>class가 가지는 고유한 값 또는 data에 상관 없이 동일하게 동작하는 method를 정의할 때 사용</p>
    <p>object, 들어오는 data에 상관없이 class에서 사용할 때 >> 메모리의 사용을 줄이게끔</p>
    <p>class class-name{ static ; constructor (){}}</p>
    <p>static 으로 선언된 내용은 호출하려면 constructor가 아닌 class를 이용해 호출해야함.</p>
    <p>class-name.static-name 의 형태</p>
    <br>

    <h3>Inheritance</h3>
    <p>각 class 에서 동일하게 나타나는 것을 class로 선언 후 method를 생성, 그리고 이를 상속하는 class 생성.</p>
    <p>class parent-class{} // class child-class extends parent-class{} 형태로 선언</p>
    <p>만약 자식 class가 사용할 method에 수정이 필요할 경우 자식 class에서 해당 부분을 재정의 가능 >> overwriting >> 다형성</p>
    <p>overwriting 하면 부모 class의 함수는 호출 X, 자식 class에 overwriting 한 부분을 호출하기 때문</p>
    <p>overwriting-method(){super.parent-class-method();} 를 하면 overwriting 한 내용 + 부모 class의 내용 모두 호출</p>
    <br>

    <h3>instanceOf</h3>
    <p>class를 통해 만들어진 새로운 object를 확인할 때 사용 >> true, false를 return</p>
    <p>모든 object는 Object를 상속한 것! >> 어떤 object던 Object를 상속해 overwriting 할 수 있음.</p>
    <br>


    <p>--------------------------------------------------------------------------------------------------------------</p>
    <br>
    <br>



</body>

</html>