<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="utf-8">
    <title>javascript learn</title>
    <script src="../learn_web/js_learn.js"></script>
</head>

<body>

    <h2>script tag 의 기초 옵션</h2>
    <br>
    <p>head tag 안에 script tag를 두면 그 tag 부분에서 html 파일의 parsing을 멈추고,</p>
    <p>js 파일이 너무 큰 경우 로딩이 너무 오래 걸림..</p>
    <br>
    <p>그래서 body tag 끝에 script tag를 두는 경우가 많음. </p>
    <p>컨텐츠 로딩이 이미 다 되어 있으니 컨텐츠는 빨리 봄. </p>
    <p>그런데 그 html 파일이 js에 의존이 큰 경우 기능 동작에 문제가 있음..</p>
    <br>
    <p>head tag 안에 script tag를 둘 때 boolean type의 asyn 옵션 두면 html parsing과 병렬로 다운로드함.</p>
    <p>body 끝 쪽에 두는 것에 비해 다운로드 받는 속도가 빠르기 때문에 준비는 빨라짐. </p>
    <p>단, 병렬로 다운로드가 끝나면 js를 excuting 하기 때문에 정작 필요한 시점에서 작동 안할 수도 있음. </p>
    <p>또 excuting js 동안 html parsing이 멈추기 때문에 용량이 클 경우 나머지 컨텐츠 로드가 늦어질 수 있음.</p>
    <br>
    <p>head tag 안에 script tag를 둘 때 defer 옵션을 두면 html parsing하면서 js를 다운로드 함.</p>
    <p>html parsing이 끝나면 excuting js, 따라서 html parsing이 끝나고 사용자에게 parsing이 끝난 화면을 보여주고 js를 실행하게 됨.</p>
    <br>
    <p>가장 안전하면서 의도한 대로 움직일 수 있는 옵션 defer !</p>
    <p>js를 만들 때 첫줄에 'use strict'; 를 작성 >> strict mode 로 개발하겠다!</p>


    <p>--------------------------------------------------------------------------------------------------------------</p>
    <br>
    <br>


    <h2>Variables 변수</h2>
    <br>

    <h3>Variable types</h3>
    <p>primitive, single item. 더이상 나눠지지 않음. >> 값 자체가 메모리에 저장됨.</p>
    <p>object, box container. single item 을 묶어서 단위로 사용.</p>
    <p>>> 크기가 커서 메모리에 바로 못올라감. 따라서 reference를 통해 실제로 저장되어 있는 메모리를 가리키게 됨.</p>
    <p>function, first-class function. >> 이게 지원된다? 그러면 변수처럼 사용 가능.</p>
    <br>
    <p>Immutable data type >> 데이터를 절대 변경하지 못함. primitive types, frozen objects</p>
    <p>Mutable data type >> 데이터를 변경할 수 있음. all objects by default are mutable in JS</p>


    <h3>ES6 부터 let ! >> Mutable Type >> rw</h3>
    <p>var는 이제 사용 X, 변수를 선언하기 전에 사용할 수 있기 때문에 오류를 유발할 수 있음.</p>
    <p>이걸 var hoisting 이라 하는데, 어디에 선언했냐에 상관 없이 선언을 최상단으로 끌어 올리는 것.</p>
    <p>즉, file 맨 위에 선언이 올라가버림. >> console 보면 undefined 로 나옴.</p>
    <p>또, block scope에 적용되지 않기 때문에 문제가 생길 수 있음.</p>
    <br>

    <h3>Constant const >> Immutable Type >> r</h3>
    <p>한번 선언하면 변경이 불가능한 변수. 따라서 항상 그 값이어야 하는 변수를 선언할 때 사용</p>
    <p>for security, thread safety, reduce human mistakes</p>
    <br>

    <p>숫자 number, JS에서는 dinamic하게 변수가 할당되기 때문에 number를 따로 선언 안해줘도 됨.</p>
    <p>단, infinity(양수를 0으로 나눔), negativeInfinity(음수를 0으로 나눔), not a number(숫자가 아닌 경우)는 표현 불가.</p>
    <p>큰 정수를 쓸 경우 bigInt type >> 숫자 뒤에 n 붙이면 됨. </p>
    <br>

    <h3>문자, 문장 string</h3>
    <p>template literals(string)을 많이 쓰는데, '${변수}, type: ${typeof 변수}' 쉽게 문장을 작성할 수 있음.</p>
    <br>

    <p>공백, null</p>
    <br>

    <h3>고유식별자, symbol</h3>
    <p>symbol로 선언한 string이 같아도 서로 다른 변수. >> 고유한 값을 가지는 식별자 </p>
    <p>만약 string이 같은 symbol을 선언할 때는 symbol.for('string'); >> 이때는 각 심볼이 서로 같음.</p>
    <br>

    <h3>JS는 Dynamic typing languages >> 변수 선언 시 따로 지정해주지 않아도 runtime에서 선언.</h3>
    <p>값에 따라 자동으로 변환도 되고 계산도 가능함.</p>
    <p>변수형을 따로 지정하지 않으면 runtime 중에 변수형이 변경되기 때문에 runtime 중에 오류가 발생할 수 있음.</p>
    <br>

    <p>구조체, object</p>
    <p></p>


    <p>--------------------------------------------------------------------------------------------------------------</p>
    <br>
    <br>

    <h2>Operator</h2>
    <br>

    <h3>String concatenation</h3>
    <p>+를 써서 문장을 합칠 수 있음. `string literals ${연산 할 내용}` 가능 (''와 혼동 조심)</p>
    <p>'string' + 숫자 일 경우, 숫자를 string으로 변환 후 문장을 합침.</p>
    <p>''로 string을 만드는 경우, 특수문자열을 이용해 문장부호나 조판부호 사용 가능.</p>
    <br>

    <h3>Numeric operator</h3>
    <p>숫자 연산에 사용. 연산부호 사용.</p>
    <br>

    <h3>Increment and decrement operator</h3>
    <p>preIncrement >> ++변수 , 변수 += 1; 과 같음. 연산 후에 대입.</p>
    <p>postIncrement >> 변수++ , 변수를 먼저 대입, 그 후에 +1</p>
    <p>preDecrement >> --변수 , 변수 -= 1; 과 같음. 연산 후에 대입.</p>
    <p>postDecrement >> 변수-- , 변수를 먼저 대입, 그 후에 -1</p>
    <br>

    <h3>Assignment operator, Comparison operator</h3>
    <p>Assignment operator >> +=, -=, *=, /= </p>
    <p>Comparison operator >>
        <,>,
            <=,>= </p>
    <br>

    <h3>Logical operator</h3>
    <p>|| >> or, 비교 대상 중 하나만 True면 True</p>
    <p>&& >> and, 비교 대상 모두가 True여야 True.</p>
    <p>>> 간단하게 null check에 쓰이기도 함. ~ nullobject가 null이 아닐 때만 값을 받아오기 떄문.</p>
    <p>|| 와 && 는 보다 심플한 대상을 앞으로. 보다 무거운 function은 뒤로!</p>
    <p>! >> 값을 반대로 바꿔줌.</p>
    <br>

    <h3>Equallity</h3>
    <p>loose equally == >> 서로 같은가? 비교 / != 는 서로 다른가? >> type을 변경해서 값을 비교</p>
    <p>strict equally === >> type을 비교해서 같은가? / !== 다른가?</p>
    <p>코딩할 땐 왠만하면 strict equally를 이용하기</p>
    <br>

    <h3>0, null, ''(empty string), undefined 는 false 로 간주!</h3>
    <br>

    <h3>Conditional operator</h3>
    <p>if elseif if 구문 >> 다른 언어랑 같음 >> if{}elseif{}else{};</p>
    <br>

    <h3>Ternary operator</h3>
    <p>조건 ? A : B >> 조건이 true면 A, 아니면 B 실행</p>
    <p>간단하게 쓸 때만 사용</p>
    <br>

    <h3>Switch statement</h3>
    <p>다른 언어의 stitch(조건){case} 와 같음</p>
    <p>if~else가 반복 될 때, typescript에서 정해져있는 type 검사할 때 등등에서 사용 </p>
    <br>

    <h3>Loop</h3>
    <p>다른 언어의 loop와 비슷함</p>
    <p>while(조건){} 은 조건 비교 후 실행, do{}while(조건) 은 일단 실행 후 조건 비교</p>
    <p>for(조건){} 은 다른 언어와 같은 방식. inline varialbe declaration 가능. 단, 중첩된 for 문은 권장 X</p>
    <br>
    <p>continue >> loop는 진행, 이번 구문만 skip</p>
    <p>break >> loop를 끝냄</p>
    <br>


    <p>--------------------------------------------------------------------------------------------------------------</p>
    <br>
    <br>



</body>

</html>